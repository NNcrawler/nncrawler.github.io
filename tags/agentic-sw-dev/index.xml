<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Agentic-Sw-Dev on rasyidhakim.com</title><link>http://rasyidhakim.com/tags/agentic-sw-dev/</link><description>Recent content in Agentic-Sw-Dev on rasyidhakim.com</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 28 Jan 2026 15:38:49 +0700</lastBuildDate><atom:link href="http://rasyidhakim.com/tags/agentic-sw-dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Tightening the Frontend Feedback Loop With Browser Aware Agents</title><link>http://rasyidhakim.com/blog/tightening-the-frontend-feedback-loop-with-browser-aware-agents/</link><pubDate>Wed, 28 Jan 2026 15:38:49 +0700</pubDate><guid>http://rasyidhakim.com/blog/tightening-the-frontend-feedback-loop-with-browser-aware-agents/</guid><description>&lt;p&gt;My initial &lt;strong&gt;frontend&lt;/strong&gt; workflow was functional but tedious.&lt;/p&gt;
&lt;p&gt;I’d discuss frontend design in ChatGPT, take screenshots, send them back, then hand things off to an agent to implement.
It worked, but every iteration felt slower than it should have been.&lt;/p&gt;
&lt;p&gt;At some point I stopped and thought: what if the agent could actually see the browser?&lt;/p&gt;
&lt;p&gt;That question led me to &lt;strong&gt;chrome-devtools-mcp&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Once the agent had visibility into the live DOM, styles, and runtime behavior, the workflow simplified.
Design and implementation collapsed into a single loop.
No more screenshot ping-pong.&lt;/p&gt;</description></item><item><title>Skills Drift Problem</title><link>http://rasyidhakim.com/blog/skills-drift-problem/</link><pubDate>Tue, 27 Jan 2026 16:01:11 +0700</pubDate><guid>http://rasyidhakim.com/blog/skills-drift-problem/</guid><description>&lt;p&gt;A quick lesson from sharing skills across coding agents&lt;/p&gt;
&lt;p&gt;When you work across multiple projects, your skills decay faster than your code.&lt;/p&gt;
&lt;p&gt;I kept copy-pasting the same skills across repos and agent-specific directories. Each project slowly drifted. Small tweaks here, forgotten updates there. I never knew which version was the real one.&lt;/p&gt;
&lt;p&gt;The problem showed up quickly, so I fixed it at the root.&lt;/p&gt;
&lt;p&gt;The solution I landed on was simple: centralize skills and sync them across projects. I built a small CLI to support that workflow, with a single source of truth and on-demand updates.&lt;/p&gt;</description></item><item><title>Why Some Coding Agents Just Work</title><link>http://rasyidhakim.com/blog/why-some-coding-agents-just-work/</link><pubDate>Mon, 26 Jan 2026 12:35:49 +0700</pubDate><guid>http://rasyidhakim.com/blog/why-some-coding-agents-just-work/</guid><description>&lt;p&gt;Over the last few weeks, I’ve been working with coding agents for my development workflows, mainly Kilo Code and Codex. I came into Codex after spending significant time with Kilo, so the contrast was immediately noticeable.&lt;/p&gt;
&lt;p&gt;Kilo felt smooth out of the box. Codex felt more erratic. My first instinct was to judge the agents.&lt;/p&gt;
&lt;p&gt;Looking closer, the difference wasn’t model capability. It was defaults.&lt;/p&gt;
&lt;p&gt;Kilo ships Distinct modes for different tasks (ask, architect, debug, code)
-Strong context and task scaffolding by default
-Built-in agent tools like a browser&lt;/p&gt;</description></item></channel></rss>